#!/usr/bin/env python3
"""
Simplified Master Agent for MSP Contract Testing
Behaves as an orchestrator but executes simple tasks directly.
"""
import argparse
import json
import sys
import os
from pathlib import Path
from datetime import datetime

def get_timestamp():
    return datetime.now().strftime('%H:%M:%S')

def read_scratchpad(path):
    """Read existing scratchpad content"""
    if path.exists():
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()
    return ""

def write_scratchpad(path, content):
    """Write scratchpad content (with 4096 char limit)"""
    # Keep only last 4096 characters if overflow
    if len(content) > 4096:
        content = content[-4096:]

    with open(path, 'w', encoding='utf-8') as f:
        f.write(content)

def append_scratchpad(path, line):
    """Append to scratchpad with overflow management"""
    content = read_scratchpad(path)
    content += line
    write_scratchpad(path, content)

def execute_task(task_desc, tools, scratchpad_path):
    """Execute task using allowed tools"""
    # Read existing scratchpad
    scratchpad_path = Path(scratchpad_path)

    append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [~] Начало задачи: {task_desc}\n")

    result = {"status": "success", "result": "", "produced_files": []}

    try:
        # Parse task and execute
        task_lower = task_desc.lower()

        # Task: Create file
        if "создай файл" in task_lower or "create" in task_lower:
            append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [~] Анализирую задачу создания файла\n")

            # Extract filename
            if "hello.txt" in task_lower:
                filename = "hello.txt"
                # Extract content
                if "привет, мир" in task_lower or "hello, world" in task_lower:
                    content = "Привет, мир!"
                else:
                    content = task_desc.split("с содержимым")[-1].strip().strip("'\"")

                append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [~] Создаю файл {filename}\n")

                # Check if file_write is allowed
                if "file_write" not in tools:
                    raise PermissionError("file_write not in allowed tools")

                # Write file
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)

                append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [X] Файл {filename} создан успешно\n")
                result["result"] = f"File {filename} created"
                result["produced_files"] = [filename]
            else:
                raise ValueError("Cannot parse filename from task")

        # Task: Append to file
        elif "добавь" in task_lower and "файл" in task_lower:
            append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [~] Анализирую задачу добавления в файл\n")

            if "hello.txt" in task_lower:
                filename = "hello.txt"

                # Extract content to append
                if "это дополнение" in task_lower:
                    append_content = "Это дополнение."
                else:
                    append_content = task_desc.split("строку")[-1].strip().strip("'\"")

                append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [~] Добавляю в файл {filename}\n")

                # Check tools
                if "file_write" not in tools and "file_read" not in tools:
                    raise PermissionError("file_write/file_read not in allowed tools")

                # Read existing content
                if not Path(filename).exists():
                    raise FileNotFoundError(f"{filename} does not exist")

                with open(filename, 'r', encoding='utf-8') as f:
                    existing = f.read()

                # Append
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(existing + "\n" + append_content)

                append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [X] Добавлено в {filename}\n")
                result["result"] = f"Appended to {filename}"
                result["produced_files"] = [filename]
            else:
                raise ValueError("Cannot parse filename from task")

        # Task: Delete file
        elif "удали файл" in task_lower or "delete" in task_lower:
            append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [~] Анализирую задачу удаления файла\n")

            if "hello.txt" in task_lower:
                filename = "hello.txt"

                append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [~] Удаляю файл {filename}\n")

                # Check tools
                if "file_delete" not in tools:
                    raise PermissionError("file_delete not in allowed tools")

                # Delete
                filepath = Path(filename)
                if not filepath.exists():
                    raise FileNotFoundError(f"{filename} does not exist")

                filepath.unlink()

                append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [X] Файл {filename} удалён успешно\n")
                result["result"] = f"File {filename} deleted"
                result["produced_files"] = []
            else:
                raise ValueError("Cannot parse filename from task")

        else:
            raise ValueError(f"Unknown task type: {task_desc}")

        append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [X] Задача завершена успешно\n")

    except Exception as e:
        append_scratchpad(scratchpad_path, f"[{get_timestamp()}] [!] Ошибка: {str(e)}\n")
        result["status"] = "failed"
        result["result"] = str(e)
        # Write error to stderr
        print(f"ERROR: {str(e)}", file=sys.stderr)

    return result

def main():
    parser = argparse.ArgumentParser(description="Simplified Master Agent - MSP Testing")
    parser.add_argument("run", nargs='?', help="Command (always 'run')")
    parser.add_argument("--task", required=True, help="Task description")
    parser.add_argument("--tools", required=True, help="Comma-separated list of allowed tools")

    args = parser.parse_args()

    # Parse tools
    tools = [t.strip() for t in args.tools.split(',')]

    # Scratchpad path is always ./scratchpad.md in current directory
    scratchpad_path = Path("./scratchpad.md")

    # Execute task
    result = execute_task(args.task, tools, scratchpad_path)

    # Output ONLY valid JSON to stdout
    print(json.dumps(result, ensure_ascii=False))

    # Exit with appropriate code
    sys.exit(0 if result["status"] == "success" else 1)

if __name__ == "__main__":
    main()
